
package calculock;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.text.DecimalFormat;
import javax.swing.JPanel;
import javax.swing.table.DefaultTableModel;

public class Fm_Principal extends javax.swing.JFrame {
//#########################################################################################################################
//##################        DEFINICION DE VARIABLES A UTILIZAR      //#####################################################
//#########################################################################################################################
//#########################################################################################################################
/*  Nota importante: Aquí no irán todas las variables, pues definiremos algunas con forme utilicemos el algoritmo, como
    aquellas donde guardaremos el valor de los puntos, de los centroides, los centroides nuevos, los viejos, etc.*/
    
    
    int n, c, m;                                  //Variables de Puntos, Centroides y Peso (respectivamente)
    double aux, aux1;                                   //Variables auxiliares para realizar algunas operaciones (pueden ser redefinidas dentro de métodos)
    int parasuma=0;                                       //**POSIBLE CANDIDATA A SER REMOVIDA** Variable auxiliar para detener las iteraciones 
    int iteracion=0;                                    //Variable con la cual contaremos cada una de las iteraciones que se vayan realizando
    DecimalFormat dec = new DecimalFormat("#0.0000");   //Variable con la cual limitaremos los valores decimales a 4 (segun deseemos)
    //Nota 2: Son de tipo [var][2] porque justamente pueden existir varios puntos, pero coordenadas solo habrá (x,y).
/*
    Variables con las cuales se operan en los formularios, ya que al declarar "new doubles" podemos aprovechar el uso d
    estas variables dinamicas y sin una longitud para lograr trabajar y que no se olvide el resultado.
*/
    double guardardatosCentroides[][];
    double guardardatosDistancia[][];
    double guardardatosMembresia[][];
    double guardardatoscentroidesNuevos[][];
    double guardardatosPuntos[][];
    double guardardatosCentroidesC[][];
    double guardardatosDistanciaC[][];
    double guardardatosMembresiaC[][];
    double guardardatoscentroidesNuevosC[][];
    double guardardatosPuntosC[][];

//#########################################################################################################################
//#########################################################################################################################
   
    public Fm_Principal() {
        initComponents();
        
    }   

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jtPuntos = new javax.swing.JTable();
        jScrollPane3 = new javax.swing.JScrollPane();
        jtCentroides = new javax.swing.JTable();
        txtPeso = new javax.swing.JTextField();
        txtCentroides = new javax.swing.JTextField();
        txtDatos = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel2 = new javax.swing.JPanel();
        jScrollPane8 = new javax.swing.JScrollPane();
        areaDistancias1 = new javax.swing.JTextArea();
        jLabel11 = new javax.swing.JLabel();
        jLabel12 = new javax.swing.JLabel();
        jScrollPane9 = new javax.swing.JScrollPane();
        areaMembresia1 = new javax.swing.JTextArea();
        jLabel13 = new javax.swing.JLabel();
        jScrollPane10 = new javax.swing.JScrollPane();
        areaFcosto1 = new javax.swing.JTextArea();
        jLabel14 = new javax.swing.JLabel();
        jScrollPane11 = new javax.swing.JScrollPane();
        areaCentroides1 = new javax.swing.JTextArea();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        areaDistancias = new javax.swing.JTextArea();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jScrollPane4 = new javax.swing.JScrollPane();
        areaMembresia = new javax.swing.JTextArea();
        jLabel9 = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        areaFcosto = new javax.swing.JTextArea();
        jLabel10 = new javax.swing.JLabel();
        jScrollPane6 = new javax.swing.JScrollPane();
        areaCentroides = new javax.swing.JTextArea();
        jScrollPane7 = new javax.swing.JScrollPane();
        vanishHelper = new javax.swing.JTextArea();
        jScrollPane12 = new javax.swing.JScrollPane();
        vanishHelper1 = new javax.swing.JTextArea();
        BOTONMALDITO = new javax.swing.JToggleButton();
        btDatosT = new javax.swing.JButton();
        btIterar = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jLabel1.setFont(new java.awt.Font("Segoe UI", 0, 24)); // NOI18N
        jLabel1.setText("CLUSTERING");
        getContentPane().add(jLabel1, new org.netbeans.lib.awtextra.AbsoluteConstraints(110, 10, -1, -1));

        jtPuntos.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "#", "P(x)", "P(y)"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, true, true
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane1.setViewportView(jtPuntos);

        getContentPane().add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(90, 60, 270, 180));

        jtCentroides.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "#", "P(x)", "P(y)"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, true, true
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane3.setViewportView(jtCentroides);

        getContentPane().add(jScrollPane3, new org.netbeans.lib.awtextra.AbsoluteConstraints(380, 60, 270, 180));

        txtPeso.setColumns(6);
        getContentPane().add(txtPeso, new org.netbeans.lib.awtextra.AbsoluteConstraints(570, 30, -1, -1));

        txtCentroides.setColumns(6);
        getContentPane().add(txtCentroides, new org.netbeans.lib.awtextra.AbsoluteConstraints(420, 30, -1, -1));

        txtDatos.setColumns(6);
        txtDatos.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtDatosActionPerformed(evt);
            }
        });
        getContentPane().add(txtDatos, new org.netbeans.lib.awtextra.AbsoluteConstraints(290, 30, 80, -1));

        jLabel2.setText("DATOS");
        getContentPane().add(jLabel2, new org.netbeans.lib.awtextra.AbsoluteConstraints(310, 10, 40, 20));

        jLabel3.setText("NÚMERO DE CENTROIDES");
        getContentPane().add(jLabel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(390, 10, 150, 20));

        jLabel4.setText("EXPONENTE DE PESO");
        getContentPane().add(jLabel4, new org.netbeans.lib.awtextra.AbsoluteConstraints(550, 10, 120, 20));

        jPanel2.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        areaDistancias1.setColumns(20);
        areaDistancias1.setRows(5);
        areaDistancias1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 153, 102)));
        areaDistancias1.setDisabledTextColor(new java.awt.Color(0, 51, 204));
        areaDistancias1.setEnabled(false);
        jScrollPane8.setViewportView(areaDistancias1);

        jPanel2.add(jScrollPane8, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 610, 90));

        jLabel11.setText("MATRIZ DE DISTANCIAS");
        jPanel2.add(jLabel11, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 0, -1, 30));

        jLabel12.setText("MATRIZ DE MEMBRESIA");
        jPanel2.add(jLabel12, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 100, -1, 30));

        jScrollPane9.setOpaque(false);

        areaMembresia1.setColumns(20);
        areaMembresia1.setRows(5);
        areaMembresia1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 153, 102)));
        areaMembresia1.setDisabledTextColor(new java.awt.Color(0, 0, 204));
        areaMembresia1.setEnabled(false);
        jScrollPane9.setViewportView(areaMembresia1);

        jPanel2.add(jScrollPane9, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 100, 610, 100));

        jLabel13.setText("NUEVOS CENTROIDES");
        jPanel2.add(jLabel13, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 210, -1, 30));

        jScrollPane10.setEnabled(false);
        jScrollPane10.setFocusable(false);
        jScrollPane10.setOpaque(false);

        areaFcosto1.setColumns(20);
        areaFcosto1.setRows(5);
        areaFcosto1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 153, 102)));
        areaFcosto1.setDisabledTextColor(new java.awt.Color(0, 51, 204));
        areaFcosto1.setEnabled(false);
        jScrollPane10.setViewportView(areaFcosto1);

        jPanel2.add(jScrollPane10, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 320, 610, 110));

        jLabel14.setText("FUNCION DE COSTO");
        jPanel2.add(jLabel14, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 320, -1, 30));

        areaCentroides1.setColumns(20);
        areaCentroides1.setRows(5);
        areaCentroides1.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 153, 102)));
        areaCentroides1.setDisabledTextColor(new java.awt.Color(0, 51, 204));
        areaCentroides1.setEnabled(false);
        jScrollPane11.setViewportView(areaCentroides1);

        jPanel2.add(jScrollPane11, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 210, 610, 100));

        jTabbedPane1.addTab("Algoritmo C Means Difuso", jPanel2);

        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        areaDistancias.setColumns(20);
        areaDistancias.setRows(5);
        areaDistancias.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 153, 102)));
        areaDistancias.setDisabledTextColor(new java.awt.Color(0, 51, 204));
        areaDistancias.setEnabled(false);
        jScrollPane2.setViewportView(areaDistancias);

        jPanel1.add(jScrollPane2, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 0, 610, 90));

        jLabel7.setText("MATRIZ DE DISTANCIAS");
        jPanel1.add(jLabel7, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 0, -1, 30));

        jLabel8.setText("MATRIZ DE MEMBRESIA");
        jPanel1.add(jLabel8, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 100, -1, 30));

        jScrollPane4.setOpaque(false);

        areaMembresia.setColumns(20);
        areaMembresia.setRows(5);
        areaMembresia.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 153, 102)));
        areaMembresia.setDisabledTextColor(new java.awt.Color(0, 0, 204));
        areaMembresia.setEnabled(false);
        jScrollPane4.setViewportView(areaMembresia);

        jPanel1.add(jScrollPane4, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 100, 610, 100));

        jLabel9.setText("NUEVOS CENTROIDES");
        jPanel1.add(jLabel9, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 210, -1, 30));

        jScrollPane5.setEnabled(false);
        jScrollPane5.setFocusable(false);
        jScrollPane5.setOpaque(false);

        areaFcosto.setColumns(20);
        areaFcosto.setRows(5);
        areaFcosto.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 153, 102)));
        areaFcosto.setDisabledTextColor(new java.awt.Color(0, 51, 204));
        areaFcosto.setEnabled(false);
        jScrollPane5.setViewportView(areaFcosto);

        jPanel1.add(jScrollPane5, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 320, 610, 110));

        jLabel10.setText("FUNCION DE COSTO");
        jPanel1.add(jLabel10, new org.netbeans.lib.awtextra.AbsoluteConstraints(610, 320, -1, 30));

        areaCentroides.setColumns(20);
        areaCentroides.setRows(5);
        areaCentroides.setBorder(javax.swing.BorderFactory.createMatteBorder(1, 1, 1, 1, new java.awt.Color(0, 153, 102)));
        areaCentroides.setDisabledTextColor(new java.awt.Color(0, 51, 204));
        areaCentroides.setEnabled(false);
        jScrollPane6.setViewportView(areaCentroides);

        jPanel1.add(jScrollPane6, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 210, 610, 100));

        vanishHelper.setColumns(20);
        vanishHelper.setRows(5);
        vanishHelper.setText("0.0000");
        vanishHelper.setToolTipText("");
        jScrollPane7.setViewportView(vanishHelper);

        jPanel1.add(jScrollPane7, new org.netbeans.lib.awtextra.AbsoluteConstraints(1331, 414, 0, 7));

        vanishHelper1.setColumns(20);
        vanishHelper1.setRows(5);
        vanishHelper1.setText("0.0000");
        vanishHelper1.setToolTipText("");
        jScrollPane12.setViewportView(vanishHelper1);

        jPanel1.add(jScrollPane12, new org.netbeans.lib.awtextra.AbsoluteConstraints(1341, 395, 0, 7));

        BOTONMALDITO.setText("GRAFICAR");
        BOTONMALDITO.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BOTONMALDITOActionPerformed(evt);
            }
        });
        jPanel1.add(BOTONMALDITO, new org.netbeans.lib.awtextra.AbsoluteConstraints(1051, 500, 226, 51));

        jTabbedPane1.addTab("Algoritmo K Means", jPanel1);

        getContentPane().add(jTabbedPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(0, 250, 750, 470));

        btDatosT.setBackground(new java.awt.Color(204, 204, 204));
        btDatosT.setText("Datos para tabla");
        btDatosT.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btDatosT.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                btDatosTMouseClicked(evt);
            }
        });
        btDatosT.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btDatosTActionPerformed(evt);
            }
        });
        getContentPane().add(btDatosT, new org.netbeans.lib.awtextra.AbsoluteConstraints(830, 10, 230, 230));

        btIterar.setText("Realizar Iteracion");
        btIterar.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        btIterar.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                btIterarMouseClicked(evt);
            }
        });
        btIterar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btIterarActionPerformed(evt);
            }
        });
        getContentPane().add(btIterar, new org.netbeans.lib.awtextra.AbsoluteConstraints(1080, 10, 240, 230));

        jPanel3.setBackground(new java.awt.Color(255, 255, 255));
        jPanel3.setForeground(new java.awt.Color(255, 255, 255));
        getContentPane().add(jPanel3, new org.netbeans.lib.awtextra.AbsoluteConstraints(760, 270, 550, 450));

        jLabel5.setText("COLOR ROJO: PUNTOS");
        getContentPane().add(jLabel5, new org.netbeans.lib.awtextra.AbsoluteConstraints(750, 250, -1, -1));

        jLabel6.setText("COLOR AZUL: CENTROIDES K MEANS");
        getContentPane().add(jLabel6, new org.netbeans.lib.awtextra.AbsoluteConstraints(890, 250, -1, -1));

        jLabel15.setText("COLOR VERDE: CENTROIDES C MEANS");
        getContentPane().add(jLabel15, new org.netbeans.lib.awtextra.AbsoluteConstraints(1110, 250, -1, -1));

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void txtDatosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtDatosActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_txtDatosActionPerformed

    private void BOTONMALDITOActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BOTONMALDITOActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_BOTONMALDITOActionPerformed

    private void btDatosTActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btDatosTActionPerformed
               
        
//#########################################################################################################################
//#########################################################################################################################
//        DOCUMENTACION SOBRE LA CREACION DE UNA TABLA QUE PUEDA SER CAMBIADA DINÁMICAMENTE:        
//#########################################################################################################################
//#########################################################################################################################
/*  Primero, usaremos la instrucción <<DefaultTableModel> con la cual obtendremos el "modelo actual" de la tabla en la
    que estamos trabajando en estos momentos, y con esto y es que lograremos obtener los "marcos" donde vemos el identificador
    de los puntos. 

    Con esto, podremos (por decirlo de alguna forma) lograr tener una tabla vacía solo preparada para que esta reciba datos
    los cuales iremos ingresando en los cuadros de texto llamados <<txtDatos>> y <<txtCentroides>>. Esto nos permitira
    definir una nueva cantidad de columnas vacias. una vez tengamos las columnas vacias, vamos a poder en estas ingresar datos
    a como el ejercicio que necesitemos ingresar nos lo solicite.

    Por último, hemos de tener en cuenta que mediante los mismos comandos, se irán agregando fila por fila la cantidad deseada
    tanto de puntos como de centroides en nuestras tablas, así que debemos asegurarnos de no dejar ningún valor vacío.*/
//#########################################################################################################################
//#########################################################################################################################
//######################################################################################//TABLA DE PUNTOS                                                                                          
        DefaultTableModel modelo1 = (DefaultTableModel)jtPuntos.getModel();             //TableModel default, el que se ve en Design
        int aX1=jtPuntos.getRowCount();                                                 //Variable que nos permitirá obtener la cantidad actual de filas
            for (int i=0 ; aX1>i ; i++) {                                               //Instrucción for en la cual recorreremos la cantidad de filas existentes
                modelo1.removeRow(0);}                                                  //Linea que eliminará la cantidad de filas existentes.                            
                                
        int a;                                              //Variable en la cual guardaremos la cantidad de filas de los Datos o Puntos
        a = Integer.parseInt(txtDatos.getText());           //Tomaremos todo lo que haya dentro de txtDatos, lo volveremos entero y lo agregaremos a la variable a

            for(int i=0; i<a; i++){                         //Ciclo for que agregará de 1 en 1 filas de puntos en jtPuntos, hasta llegar a la cantidad puesta en txtDatos
                modelo1.addRow(new Object[]{(jtPuntos.getRowCount()+1), null, null});}
//#########################################################################################################################
//#########################################################################################################################
//######################################################################################//TABLA DE CENTROIDES            
        DefaultTableModel modelo2 = (DefaultTableModel)jtCentroides.getModel();         //TableModel default, el que se ve en Design
        int aX2=jtCentroides.getRowCount();                                             //Variable que nos permitirá obtener la cantidad actual de filas
            for (int i=0 ; aX2>i ; i++) {                                               //Instrucción for en la cual recorreremos la cantidad de filas existentes
                modelo2.removeRow(0);}                                                  //Linea que eliminará la cantidad de filas existentes. 
        
        int b;                                              //Variable en la cual guardaremos la cantidad de filas de los Datos o Puntos
        b = Integer.parseInt(txtCentroides.getText());      //Tomaremos todo lo que haya dentro de txtDatos, lo volveremos entero y lo agregaremos a la variable a
            
            for(int i=0; i<b; i++){                         //Ciclo for que agregará de 1 en 1 filas de puntos en jtPuntos, hasta llegar a la cantidad puesta en txtDatos
                modelo2.addRow(new Object[]{(jtCentroides.getRowCount()+1), null, null});}
//#########################################################################################################################
//#########################################################################################################################

//ZONA DE PRUEBAS
    }//GEN-LAST:event_btDatosTActionPerformed

    private void btIterarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btIterarActionPerformed

//#########################################################################################################################
//#########################################################################################################################
//        DOCUMENTACION SOBRE LA CREACION DE UNA TABLA QUE PUEDA SER CAMBIADA DINÁMICAMENTE:        
//#########################################################################################################################
//#########################################################################################################################
/*  Las iteraciones en nuestro algoritmo nos irán indicando los valores que vamos a ir adquiriendo, paso a paso.

    La idea en este botón, es que cada que se realice un evento de click sobre el, despliegue en los dos tipos de algoritmos
    la iteración. Con esto, es que podremos ir viendo como es que los dos funcionan. Después, mediante el uso de alguna
    variable hemos de conocer el valor de parada, o cuando los centroides se vuelvan exactamente los mismos y se logre
    desactivar la ejecución de alguno de estos algoritmos.

    Por ello es que aquí no habrá una interacción de inicio como tal, y se comenzará a trabajar todas las transformaciones
    que sean necesarias para lograr una correcta ejecución del algoritmo. Al fin y al cabo, ya estamos seguros que los datos
    si son desplegados correctamente (aunque varian algunos por el uso de los cuatro decimales que ha pedido la profesora
    Karla. Justo así también tenemos todos nuestros apuntes).*/
//#########################################################################################################################

//#########################################################################################################################
//#########################################################################################################################
//##################        CALCULO DE LA MATRIZ DE DISTANCIAS (TANTO DE C COMO DE K MEANS ################################
//#########################################################################################################################
//#########################################################################################################################

/*  El cálculo de la matriz de distancias, en los dos algoritmos, se realiza de la misma forma. 

                RAIZ DE [((x2 − x1)^2) + ((y2 − y1)^2)]

    Gracias a eso, es que podemos ahorrarnos una interacción al calcular y agregar al mismo tiempo los valores de C y K.
    Procederemos a obtener el valor de todo lo que ingresamos en la tabla, para que de esta forma podamos realizar
    esa potencia de la diferencia de las coordenadas x y y (de los centroides y de los puntos). Para despues sacarles una raiz
    y de esta forma obtener la matriz de pertenencia, pero después trabajaremos un arreglo de una forma especial, para
    lograr mostrarla de forma adecuada a como lo pide el ejercicio.
    
*/

//#########################################################################################################################
//#########################################################################################################################

    n = Integer.parseInt(txtDatos.getText());           //Asignaremos a n (puntos) el valor del recuadro txtDatos para obtener el valor de los puntos
    c = Integer.parseInt(txtCentroides.getText());      //Asignaremos a c (centroides) el valor del recuadro txtCentroides para obtener el valor de los centroides
    
    
    
    //ASIGNACION DE LA TABLA DE PUNTOS
    double punto[][] = new double[n][2];                            //Definiremos un arreglo bidimensional de tipo double (coma flotante) para registrar los valores de los puntos
    for(int i=0; i<n; i++){                                                     //Arreglo para recorrer el arreglo bidimensional y guardar los valores de la tabla
            punto[i][0]=Double.parseDouble(jtPuntos.getValueAt(i,1).toString());    //Primero guardaremos el de i,1 (siendo la coordenada x)
            punto[i][1]=Double.parseDouble(jtPuntos.getValueAt(i,2).toString());}   //Y luego el de i,2 (siendo el de la coordenada y)
    
    
        
   borrar();  
    for(int i=0; i<n; i++){
        dibujar();
        dibujarPuntoP(punto[i][0], punto[i][1]);
    }
    //ASIGNACION DE LA TABLA DE CENTROIDES
    double centroides[][] = new double [c][2];                      //Definiremos un arreglo bidimensional de tipo double (coma flotante) para registrar los valores de los centroides.
    
    for(int i=0; i<c; i++){                                                             //Arreglo para recorrer el arreglo bidimensional y guardar los valores de la tabla
        centroides[i][0]=Double.parseDouble(jtCentroides.getValueAt(i, 1).toString());  //Primero guardaremos el de i,1 (siendo la coordenada x)
        centroides[i][1]=Double.parseDouble(jtCentroides.getValueAt(i, 2).toString());
        } //Y luego el de i,2 (siendo el de la coordenada y)
    
                                                            //Vamos a evaluar si es la primera iteracion o no, para saber si la
    if(guardardatosCentroides!=null){                       //variable dinamica tiene datos ya asignados o no, y así remplazarlos.
        centroides = guardardatosCentroides;
    
    for(int i=0; i<c; i++){                                                             //Codigo para dibujar las lineas y los centroides
        dibujar();
        dibujarPuntoC(guardardatosCentroides[i][0], guardardatosCentroides[i][1]);
        }
    }
//#########################################################################################################################
//#########################################################################################################################
//#####################Trabajar la matriz de distancias y asignarla mediante el calculo.
double resultadoMatrizDistancia[][] = new double[c][n];         //Arreglo bidimensional donde guardaremos los resultados de la matriz.

    
    for(int i=0; i<n; i++){                 //Recorreremos punto por punto, partiendo de j hasta i
        for(int j=0; j<c; j++){             //Y realizaremos el cálculo antes mencionado en la documentación.
                                            //Esto lo logreremos mediante Math.sqrt (raiz) y Math.pow (potencia).
            resultadoMatrizDistancia[j][i] = Math.sqrt((Math.pow(punto[i][0] - centroides[j][0], 2)) + (Math.pow(punto[i][1] - centroides[j][1], 2)));
        }
    }
//#########################################################################################################################
//#########################################################################################################################
    //Al iniciar caada iteración, primero limpiaremos la pantalla para evitar que se vea mal el código.
    areaDistancias.setText("");
    
    iteracion++;
    System.out.println(iteracion);
    areaDistancias.append("Iteracion " + iteracion + "\n");
    for(int i=0; i<c; i++){
        for(int j=0; j<n; j++){                                                         //Append puede agregar y agregar datos sin necesidad de eliminar ningún valor o de editar un string
            areaDistancias.append(dec.format(resultadoMatrizDistancia[i][j])+ "  |  "); //Imprimiremos el valor del resultado mas una separación
        }areaDistancias.append("\n");                                                 //Y un salto de linea cuando termine cada "grupo".
    }
/*  Y aquí es donde terminal el cálculo de la matriz, ya que gracias a esto es que podremos ya tener únicamente los resultados de las matrices
    y gracias también a que son variables globales, pueden ser consultadas únicamente una vez.
    
    */
//#########################################################################################################################
//#########################################################################################################################
//##################        CALCULO DE LA MATRIZ DE MEMBRESIA (C Y K MEANS)                ################################
//#########################################################################################################################

    double resultadoMatrizMembresia[][] = new double[c][n];                     //Dentro de esta funcion, lo que lograremos
        for(int i=0; i<n; i++){                                                 //es recorrer cada parte del arreglo, para que 
            for(int j=0; j<c; j++){                                             //despues, podamos calcular cual de todos los
                double reasign=0;                                               //datos es el menor. la variable "reasign" tomará            
                aux=resultadoMatrizDistancia[j][i];                             //la labor de ser una variable donde guardaremos    
                reasign=resultadoMatrizDistancia[j][i];                         //el valor que vamos a comparar en todas las columnas
                    int contar=0;                                               //y despues, mediante otra busqueda evaluaremos        
                        for(int k=0; k<c; k++){                                 //si es que se le asignó el valor de uno y despues    
                            if((reasign <= resultadoMatrizDistancia[k][i])){    //si es que de esta forma, hay mas valores iguales y que
                            contar++;}                                          //al tener valor de 1 uno de ellos, los demas tambien
                            if(contar==(c)){                                    //deberian adquirirlo.
                                resultadoMatrizMembresia[j][i] = 1;}
                            else{
                                resultadoMatrizMembresia[j][i] = 0;}}}}
//#########################################################################################################################
//#########################################################################################################################
//  Vaciado de texto y asignación en cada uno de los bloques, para que despues podamos simplemente operarlos
        areaMembresia.setText("");
//#########################################################################################################################
//#########################################################################################################################
//  En este codigo, gracias a la variable "iteracion" que se encuentra más arriba y ya que le hemos sumado, podemos
//  lograr mostrar la tabla gracias al ciclo de i y de j, de la forma de la matriz como solicita el ejercicio.
        areaMembresia.append("Iteración " + Integer.toString(iteracion) + "\n");
            for(int i=0; i<c; i++){
                for(int j=0; j<n; j++){
                    areaMembresia.append(dec.format(resultadoMatrizMembresia[i][j]) + "  |  "); } ///Y AL FINAL SOLO SE IMPRIME
                    areaMembresia.append("\n");}
//#########################################################################################################################
//#########################################################################################################################
/////////////////////////////////////////
//A VER LOS NUEVOS CENTROIDES

double centroidesNuevos[][] = new double [c][2];                                //Creacion de un double para guardar los datos de los centroides nuevos
    
//#########################################################################################################################
//#########################################################################################################################
//  Dibujo de los centrides "pasados"
    for(int i=0; i<c; i++){
        dibujarPuntoC(centroides[i][0], centroides[i][1]);
    }
//#########################################################################################################################
//#########################################################################################################################    
/*
    Con este ciclo, lo que haremos es inicializar la variable "contador centroides" a cero para saber cuantos ceros y unos
    habrá en cada uno de los grupos a recorrer, después gracias a este mismo contador sabremos sobre cuanto dividir el valor
    de la suma de todas las coordenadas de los puntos y asi obtener el valor de los centroides nuevos.
*/
//#########################################################################################################################
//#########################################################################################################################
    for(int i=0; i<c; i++){
            int contadorCentroides = 0;
            for(int j=0; j<n; j++){
                if(resultadoMatrizMembresia[i][j] == 1){
                    contadorCentroides++;
                    centroidesNuevos[i][0] += punto[j][0];
                    centroidesNuevos[i][1] += punto[j][1];
                    }}
            centroidesNuevos[i][0] = centroidesNuevos[i][0]/contadorCentroides;
            centroidesNuevos[i][1] = centroidesNuevos[i][1]/contadorCentroides;}
//#########################################################################################################################
//#########################################################################################################################
/*
    Mediante la variable de guardardatosCentroides, podremos redefinir las variables dinamicas sin dimension que logramos
    declarar como globales, y así poder mostrar en cada iteracion valores diferentes sin perder datos por los doubles definidos anteriormente.
*/
    guardardatosCentroides = centroidesNuevos;
//#########################################################################################################################
//#########################################################################################################################    
/*
    Area para mostrar los centroides, igual que en la parte de detras.
*/    
    areaCentroides.setText("");
        areaCentroides.append("Iteración " + Integer.toString(iteracion) + "\n");    
            for(int i=0; i<c; i++){
                areaCentroides.append("Centroide " + (i+1) + ": " + dec.format(guardardatosCentroides[i][0]) + ", " + dec.format(guardardatosCentroides[i][1]) + "\n");
            }
//#########################################################################################################################
//#########################################################################################################################
//    Calculo de la funcion de costo
//#########################################################################################################################
//#########################################################################################################################
    double funcionCosto[] = new double [c]; //Variable del costo en función a los centroides
            double costoFinal=0;                                                    //Variable para guardar el resultado del costo final
            for(int i=0; i<c; i++){                                                 //Ciclo para recorrer la matriz de membresia
                funcionCosto[i]=0;                                                  //variable en la cual guardar los datos de la matriz
                for(int j=0; j<n; j++){
                    if(resultadoMatrizMembresia[i][j]==1){
                        funcionCosto[i]+=resultadoMatrizDistancia[i][j];}}}
        for(int i=0; i<c; i++){
                costoFinal += funcionCosto[i];}                                     //asignación de los grupos resultantes.

//#########################################################################################################################
//#########################################################################################################################        
        
        areaFcosto.setText("");
        areaFcosto.append("Iteración " + Integer.toString(iteracion) + "\n");
        
        for(int i=0; i<c; i++){
                areaFcosto.append("Grupo " + (i+1) + ": " + dec.format(funcionCosto[i]) + "\n");}
                areaFcosto.append("Coste total: " + dec.format(costoFinal) + "\n");
              
//#########################################################################################################################
//#########################################################################################################################
//        CONTINUACIÓN: ALGORITMO C MEANS DIFUSO (PUES EL K ES C MEANS SIMPLEMENETE)       
//#########################################################################################################################
//#########################################################################################################################            
/*
    Aqui tenemos varios cuestionamientos, pues veremos que arriba hay definidas una gran cantidad de variables, pero si
    queremos que el programa mantenga la integridad correctamente, hemos de definir unas completamente nuevas y operar sobre
    de estas, para no alterar los datos de la interacción anterior, por ello es que definiremos nuevas variables locales
    y globales.

    Seguramente cambie la documentación de aquí en adelante, será más laxa pues solamente repetiremos unas cosas, al menos
    hasta el caso de definir la matriz, pero despues de los centroides hemos de realizar diferentes cálculos y por tanto
    esto deberá cambiar, pero ya nos aseguraremos de lograrlo.

*/
//#########################################################################################################################
//#########################################################################################################################
//        MATRIZ DE DISTANCIAS: (CON VARIABLE PARA C MEANS)  
//#########################################################################################################################
//#########################################################################################################################   

    n = Integer.parseInt(txtDatos.getText());
    c = Integer.parseInt(txtCentroides.getText());
    m = Integer.parseInt(txtPeso.getText());                    //Definida M porque aquí si importa el peso.
        
    double puntoC[][] = new double[n][2];                            //Definiremos un arreglo bidimensional de tipo double (coma flotante) para registrar los valores de los puntos
    for(int i=0; i<n; i++){                                                     //Arreglo para recorrer el arreglo bidimensional y guardar los valores de la tabla
            puntoC[i][0]=Double.parseDouble(jtPuntos.getValueAt(i,1).toString());    //Primero guardaremos el de i,1 (siendo la coordenada x)
            puntoC[i][1]=Double.parseDouble(jtPuntos.getValueAt(i,2).toString());}   //Y luego el de i,2 (siendo el de la coordenada y)
      
    
    //ASIGNACION DE LA TABLA DE CENTROIDES
    double centroidesC[][] = new double [c][2];                      //Definiremos un arreglo bidimensional de tipo double (coma flotante) para registrar los valores de los centroides.
    
    for(int i=0; i<c; i++){                                                             //Arreglo para recorrer el arreglo bidimensional y guardar los valores de la tabla
        centroidesC[i][0]=Double.parseDouble(jtCentroides.getValueAt(i, 1).toString());  //Primero guardaremos el de i,1 (siendo la coordenada x)
        centroidesC[i][1]=Double.parseDouble(jtCentroides.getValueAt(i, 2).toString());
        } //Y luego el de i,2 (siendo el de la coordenada y)
//#########################################################################################################################
//#########################################################################################################################    
//Guardado de la variable, solo que esta vez será con variables especialmente definidas para C means    
    if(guardardatosCentroidesC!=null){
    centroidesC = guardardatosCentroidesC;
//#########################################################################################################################
//#########################################################################################################################    
    
//#########################################################################################################################
//#########################################################################################################################
/*
    Se guardaran los datos de los centroides en el código de arriba, y en este se imprimirán en el gráfico del JPanel3, pero
    ahora de color verde, para lograr diferenciarlos.
*/
    for(int i=0; i<c; i++){
        dibujarPuntoCM(guardardatosCentroidesC[i][0], guardardatosCentroidesC[i][1]);
    }}
//#########################################################################################################################
//#########################################################################################################################

    
    double resultadoMatrizDistanciaC[][] = new double[c][n];         //Arreglo bidimensional donde guardaremos los resultados de la matriz.

//#########################################################################################################################
//#########################################################################################################################    
    for(int i=0; i<n; i++){                 //Recorreremos punto por punto, partiendo de j hasta i
        for(int j=0; j<c; j++){             //Y realizaremos el cálculo antes mencionado en la documentación.
                                            //Esto lo logreremos mediante Math.sqrt (raiz) y Math.pow (potencia).
            resultadoMatrizDistanciaC[j][i] = Math.sqrt((Math.pow(puntoC[i][0] - centroidesC[j][0], 2)) + (Math.pow(puntoC[i][1] - centroidesC[j][1], 2)));
        }
    }
//#########################################################################################################################
//#########################################################################################################################    
    //Al iniciar caada iteración, primero limpiaremos la pantalla para evitar que se vea mal el código.
//#########################################################################################################################
//#########################################################################################################################  
    areaDistancias1.setText("");
    areaDistancias1.append("Iteracion " + iteracion + "\n");
    for(int i=0; i<c; i++){
        for(int j=0; j<n; j++){                                                         //Append puede agregar y agregar datos sin necesidad de eliminar ningún valor o de editar un string
            areaDistancias1.append(dec.format(resultadoMatrizDistanciaC[i][j])+ "  |  "); //Imprimiremos el valor del resultado mas una separación
        } 
         areaDistancias1.append("\n");                                                  //Y un salto de linea cuando termine cada "grupo".
    }
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
/*
    CONSTRUCCIÓN DE LAS VARIABLES QUE USAREMOS EN ESTE SECTOR, DEFINIDAS UN POCO MÁS ARRIBA DE DONDE SUS PERTENENCIAS
    POR DINAMISMO DEL CÓDIGO, PARA EVITAR QUE OCURRAN ERRORES PUES EN FUZZY SE USA MATH Y LUEGO DIVISIONES QUE PUEDEN
    VOLVER EL ARREGLO DOUBLE COMO NO DINMICO Y PROVOCAR ERRORES
*/
        double resultadoMatrizMembresiaC[][] = new double [c][n]; //EN ESTA VARIABLE SE GUARDARÁN LOS RESULTADOS DE LA MATRIZ DE M
        double centroidesNuevosC[][] = new double [c][2]; //VARIABLE PARA GUARDAR LOS NUEVOS CENTROIDES   
        double costeC[] = new double [c];
        double nuevoCentroideX1C = 0, nuevoCentroideX2C = 0, nuevoCentroideY1C = 0, nuevoCentroideY2C = 0;
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
/*
    Calculo de la matriz de pertenencia, basandonos en que el cálculo esta vez necesita de hacer una división y despues
    de una division, lograr tomar el exponente de peso apra luego operarlo y hacer el cálculo, a diferencia de la matriz de
    detras, se necesita de saber los valores de pertenencia que van del cero al uno y no solo ceros y unos.
*/
//#########################################################################################################################
//#########################################################################################################################
    //PERTENENCIA
//#########################################################################################################################
//#########################################################################################################################
/*
    Se recorrera el arreglo, y mediante calculos sobre la matriz de membresia para CMeans, se tomará el resultado y se
    guardará en la misma matriz de membresia, solo que arriba es una suma y debajo se opera correctamente ya punto por punto.
*/
    for(int i=0; i<n; i++){
        for(int j=0; j<c; j++){
            resultadoMatrizMembresiaC[j][i] = 0;
            for(int k=0; k<c; k++){
                resultadoMatrizMembresiaC[j][i] += Math.pow(resultadoMatrizDistanciaC[j][i]/resultadoMatrizDistanciaC[k][i] ,2/(m-1));}  
                resultadoMatrizMembresiaC[j][i] = 1/resultadoMatrizMembresiaC[j][i];                  
        } 
    }      
//#########################################################################################################################
//#########################################################################################################################
//          Zona para asignar los datos.
//#########################################################################################################################
//#########################################################################################################################
            areaMembresia1.setText("");
            areaMembresia1.append("Iteración " + Integer.toString(iteracion) + "\n");
//#########################################################################################################################
//#########################################################################################################################            
//Mostrar matriz de pertenencia
//#########################################################################################################################
//#########################################################################################################################            
            for(int i=0; i<c; i++){
                for(int j=0; j<n; j++){
                    areaMembresia1.append(dec.format(resultadoMatrizMembresiaC[i][j]) + "   |   ");
                }
                areaMembresia1.append("\n");
            }
//#########################################################################################################################
//#########################################################################################################################
    double centroidesViejosC[][] = new double [c][2]; //VARIABLE PARA GUARDAR LOS NUEVOS CENTROIDES
    centroidesViejosC=centroidesC;                    //ASIGNACION DE VALORES DE CENTROIDES VIEJOS A LA VARIABLE CENTROIDES VIEJOS
//#########################################################################################################################
//#########################################################################################################################
//  DIBUJO DE LOS PUNTOS DE CMEANS EN COLOR VERDE.
    for(int i=0; i<c; i++){
        dibujarPuntoCM(centroidesC[i][0], centroidesC[i][1]);
    }
//#########################################################################################################################
//#########################################################################################################################            
//#########################################################################################################################
//#########################################################################################################################
/*
    En esta parte, realizaremos el CALCULO DE LOS NUEVOS CENTROIDES, pero esta vez usando variables extras con las cuales
    vamos a guardar cada uno de los puntos, pues tenemos que operar con los puntos viejos y para ello necesitaremos de la
    ayuda de unas variables nuevas que nos puedan definir tanto las coordenadas x y y.
*/
//#########################################################################################################################
//#########################################################################################################################
    for(int i=0; i<c; i++){                         //RECORRIDO DE LOS CENTROIDES NUEVOS
        centroidesNuevosC[i][0] = 0;                //VARIABLES INICIALIZADAS EN CERO PARA OPERAR SEGURAMENTE
        centroidesNuevosC[i][1] = 0;}
            
    for(int i=0; i<c; i++){                     //RECORRIDOS
        for(int j=0; j<n; j++){                 //DE LOS CENTROIDES
            for(int k=0; k<2; k++){             //RECORRIDO ESPECIAL PARA ASIGNAR PUNTOS A LOS AUXILIARES
                if(k == 0){
                    nuevoCentroideX1C += Math.pow(resultadoMatrizMembresiaC[i][j], m) * puntoC[j][k];   //CALCULO DE X1 
                    nuevoCentroideX2C += Math.pow(resultadoMatrizMembresiaC[i][j], m);                  //CALCULO DE X2
                    centroidesNuevosC[i][k] = nuevoCentroideX1C / nuevoCentroideX2C;}                   //ASIGNACION NUEVA
                if(k == 1){
                    nuevoCentroideY1C += Math.pow(resultadoMatrizMembresiaC[i][j], m) * puntoC[j][k];   //CALCULO DE Y1
                    nuevoCentroideY2C += Math.pow(resultadoMatrizMembresiaC[i][j], m);                  //CALCULO DE Y2
                    centroidesNuevosC[i][k] = nuevoCentroideY1C / nuevoCentroideY2C;}                   //ASIGNACION NUEVA
            }                    
        }
        /*
            Se devuelve el valor de los centroides de ayuda a cero, para poder volver a operarlos pues como podemos ver,
            aun no salimos del ciclo for. si no hasta la llave que se muestra debajo.
        */
            nuevoCentroideX1C = 0;                  //REINICIALIZACION A CERO
            nuevoCentroideX2C = 0;
            nuevoCentroideY1C = 0;
            nuevoCentroideY2C = 0;
    }
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
//          impresion en pantalla.
//#########################################################################################################################
//#########################################################################################################################
            guardardatosCentroidesC = centroidesNuevosC;
            areaCentroides1.setText("");
            areaCentroides1.append("Iteración " + Integer.toString(iteracion) + "\n");
            //Mostrar nuevos centroides
            
            for(int i=0; i<c; i++){
                areaCentroides1.append("Centroide " + (i+1) + ": " + dec.format(guardardatosCentroidesC[i][0]) + ", " + dec.format(guardardatosCentroidesC[i][1]) + "\n");
            }        
            
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
/*
    Por ultimo, veremos las funciones de costo, para las cules usaremos un valor donde se pueda guardar cada una de las
    multiplicaciones del valor de la matriz de membresia con las coordenadas de los puntos, con las coordenadas, y así
    terminar correctamente los calculos
*/
//#########################################################################################################################
//#########################################################################################################################
    double costeTotalC = 0;         //Variable donde guardar la suma.
    for(int i=0; i<c; i++){
        costeC[i] = 0;
            for(int j=0; j<n; j++){
                costeC[i] += Math.pow(resultadoMatrizMembresiaC[i][j], m) * Math.pow(resultadoMatrizDistanciaC[i][j], 2);
                System.out.println(costeC[i]);  
            }
    }
    for(int i=0; i<c; i++){
        costeTotalC += costeC[i];
    }
//#########################################################################################################################
//#########################################################################################################################
/*
    Se termina el calculo de costes y se sigue con la ultima impresion, sin valor de parada.
*/
    areaFcosto1.setText("");
    areaFcosto1.append("Iteración " + Integer.toString(iteracion) + "\n");
    for(int i=0; i<c; i++){
        areaFcosto1.append("Grupo " + (i+1) + ": " + dec.format(costeC[i]) + "\n");
    }
        areaFcosto1.append("Coste total: " + dec.format(costeTotalC) + "\n");
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
/*
    Este es el FIN del código de la funcion principal, ya documentada. La siguiente llave cierra todo el boton iterar.
*/
    }//GEN-LAST:event_btIterarActionPerformed
    
    
    
    private void btIterarMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btIterarMouseClicked
        // TODO add your handling code here:
        
    
        
    }//GEN-LAST:event_btIterarMouseClicked

    private void btDatosTMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btDatosTMouseClicked
        // TODO add your handling code here:
        //@Override  
    }//GEN-LAST:event_btDatosTMouseClicked

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Fm_Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Fm_Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Fm_Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Fm_Principal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
            }
        });
    }
    //#########################################################################################################################
//#########################################################################################################################//#########################################################################################################################
//#########################################################################################################################
    //#########################################################################################################################
//#########################################################################################################################//#########################################################################################################################
//#########################################################################################################################
    /*
        En esta parte se definen los constructores para dibujar.
    */
    public void borrar(){
        int w1=550;
        int h1=450;
        Graphics2D g=(Graphics2D)jPanel3.getGraphics();
        g.clearRect(0, 0, w1, h1);
    }
    
    public void dibujar(){
    double w=550;
    int w1=550;
    int h1=450;
    double h=450;
    double escala=35;    
    Graphics2D g=(Graphics2D)jPanel3.getGraphics();
    
        double x2=w/2;
        for(double x=w/2; x<w; x+=escala){
            g.setColor(Color.gray);
            g.draw(new Line2D.Double(x, 0, x,h));
            g.draw(new Line2D.Double(x2, 0, x2,h));
            x2=x2-escala;
        }
        double y2=h/2;
        for(double y=h/2; y<h; y+=escala){
            g.setColor(Color.gray);
            g.draw(new Line2D.Double(0, y, w,y));
            g.draw(new Line2D.Double(0, y2, w,y2));
            y2=y2-escala;
        }
        g.setColor(Color.blue);
        g.draw(new Line2D.Double(w/2, 0, w/2,h));
        g.draw(new Line2D.Double(0, h/2, w,h/2));
}
    
    public void dibujarPuntoP(double x, double y){
    double w=550;
    double h=450;
    double escala=35;    
    Graphics2D g=(Graphics2D)jPanel3.getGraphics();
    
        double xDigital=w/2+x*escala;
        double yDigital=h/2-y*escala;
        
        Rectangle2D rect = new Rectangle2D.Double((xDigital-7), (yDigital-7), (14), (14));
        g.setColor(Color.red);
        g.draw(rect);
    }
    public void dibujarPuntoC(double x, double y){
    
    double w=550;
    double h=450;
    double escala=35;    
    Graphics2D g=(Graphics2D)jPanel3.getGraphics();
        double xDigital=w/2+x*escala;
        double yDigital=h/2-y*escala;
        
        Rectangle2D rect = new Rectangle2D.Double((xDigital-7), (yDigital-7), (14), (14));
        g.setColor(Color.blue);
        g.draw(rect);
    }
    public void dibujarPuntoCM(double x, double y){
    
    double w=550;
    double h=450;
    double escala=35;    
    Graphics2D g=(Graphics2D)jPanel3.getGraphics();
        double xDigital=w/2+x*escala;
        double yDigital=h/2-y*escala;
        
        Rectangle2D rect = new Rectangle2D.Double((xDigital-7), (yDigital-7), (14), (14));
        g.setColor(Color.green);
        g.draw(rect);
    }
    public void borrarPuntoC(double x, double y){
    double w=550;
    double h=450;
    double escala=35;    
    Graphics2D g=(Graphics2D)jPanel3.getGraphics();
    
        double xDigital=w/2+x*escala;
        double yDigital=h/2-y*escala;
        
        Rectangle2D rect = new Rectangle2D.Double((xDigital-7), (yDigital-7), (14), (14));
        g.setColor(Color.white);
        g.draw(rect);
    }
    // fin de constructores para dibujar.
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
//#########################################################################################################################
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JToggleButton BOTONMALDITO;
    private javax.swing.JTextArea areaCentroides;
    private javax.swing.JTextArea areaCentroides1;
    private javax.swing.JTextArea areaDistancias;
    private javax.swing.JTextArea areaDistancias1;
    private javax.swing.JTextArea areaFcosto;
    private javax.swing.JTextArea areaFcosto1;
    private javax.swing.JTextArea areaMembresia;
    private javax.swing.JTextArea areaMembresia1;
    private javax.swing.JButton btDatosT;
    private javax.swing.JButton btIterar;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane10;
    private javax.swing.JScrollPane jScrollPane11;
    private javax.swing.JScrollPane jScrollPane12;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane6;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JScrollPane jScrollPane8;
    private javax.swing.JScrollPane jScrollPane9;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTable jtCentroides;
    private javax.swing.JTable jtPuntos;
    private javax.swing.JTextField txtCentroides;
    private javax.swing.JTextField txtDatos;
    private javax.swing.JTextField txtPeso;
    private javax.swing.JTextArea vanishHelper;
    private javax.swing.JTextArea vanishHelper1;
    // End of variables declaration//GEN-END:variables
}
